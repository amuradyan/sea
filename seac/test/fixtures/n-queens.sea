; On the board below, the position of Q is (2 3)
; First goes the rank, then the file
;
;   \ 1 2 3
;   1 # # #
;   2 # # Q
;
; The following are the two solution for
;   (solve 2 3 2)
; , where x marks the covered lines
;
;   \ 1 2 3
;   1 x x Q  ... (1 3)
;   2 Q x x  ... (2 1)
;
;   \ 1 2 3
;   1 Q x x  ... (1 1)
;   2 x x Q  ... (2 3)

( ; The n-queens problem
  (define max-file 4)
  (define max-rank 4)

  (define position cons)

  (define increment
    (lambda (number) (+ number 1)))

  (define decrement
    (lambda (number) (- number 1)))

  (define rank-of car)

  (define file-of
    (lambda (position) (car (cdr position))))

  (define list
    (lambda (.elements) .elements))

  ; Should return the car id there's only one element
  (define identity
    (lambda (.value) .value))

  (define queen-at identity)

  (define calculate-covered-files
    (lambda (queen)
      (
        (define file (file-of queen))

        (define loop
          (lambda (rank)
            (cond
              ((same? rank max-rank)
                (list (position rank file)))
              (else
                (cons
                  (position rank file)
                  (loop (increment rank)))))))

        (loop 1))))

  (define calculate-covered-ranks
    (lambda (queen)
      (
        (define rank (rank-of queen))

        (define loop
          (lambda (file)
            (cond
              ((same? file max-file)
                (list (position rank file)))
              (else
                (cons
                  (position rank file)
                  (loop (increment file)))))))

        (loop 1))))

  (define find-anti-diagonal-origin
    (lambda (square)
      (
        (define rank-distance
          (- (file-of square) 1))
        (define file-distance
          (- max-file (rank-of square)))

        (cond
          ((lt? rank-distance file-distance)
            (position
              (+ (file-of square) rank-distance)
              (- (rank-of square) rank-distance)))
          ((gt? rank-distance file-distance)
            (position
              (+ (file-of square) file-distance)
              (- (rank-of square) file-distance)))
          (else
            (position max-file 1))))))

  (define calculate-covered-anti-diagonal
    (lambda (queen)
      (
        (define origin
          (find-anti-diagonal-origin queen))

        (define loop
          (lambda (rank file)
            (cond
              ((or (same? rank 1) (same? file max-file))
                (list (position rank file)))
              (else
                (cons
                  (position rank file)
                  (loop (decrement rank) (increment file)))))))

        (loop (rank-of origin) (file-of origin)))))

  (define find-main-diagonal-origin
    (lambda (square)
      (
        (define square-rank (rank-of square))
        (define square-file (file-of square))

        (cond
          ((lt? square-rank square-file)
            (position 1 (increment (- square-file square-rank))))
          ((lt? square-file square-rank)
            (position (increment (- square-rank square-file)) 1))
          (else (position 1 1))))))

  (define calculate-covered-main-diagonal
    (lambda (queen)
      (
        (define origin
          (find-main-diagonal-origin queen))

        (define loop
          (lambda (rank file)
            (cond
              ((or (same? max-rank rank) (same? max-file file))
                (list (position rank file)))
              (else
                (cons
                  (position rank file)
                  (loop (increment rank) (increment file)))))))

        (loop (rank-of origin) (file-of origin))))))

  (define generate-board
    (lambda (x y)
      (
        (define generate-board-helper
          (lambda (current-x current-y)
            (cond
              ((and (same? current-x x) (same? current-y y))
                (cons
                  (pair current-x current-y)
                  (quote ())))
              ((and (lt? current-x x) (same? current-y y))
                (cons
                  (pair current-x current-y)
                  (generate-board-helper (+ 1 current-x) 1)))
              (else
                (cons
                  (pair current-x current-y)
                  (generate-board-helper current-x (+ 1 current-y)))))))

        (generate-board-helper 1 1))))

  (define solve
    (lambda (height width queens)
      (???)))

  (solve 2 3 2))
